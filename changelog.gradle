plugins {
    // prints pretty changelogs from git
    // see homepage: https://git-scm.com/
    // see plugin: https://github.com/selesse/gradle-git-changelog
    id "com.selesse.git.changelog" version "0.1.2"
}

changelog {
    // The title appears at the top of the changelog.
    // Default value: the name of the project.
    title = "${project.name} - Changelog"

    // The output directory where the report is generated.
    // Default value: main resource directory, or the "build" directory
    outputDirectory = file("$projectDir")

    // The name of the report to generate.
    // Default value: CHANGELOG.md
    fileName = "CHANGELOG.md"

    // The range of commits the changelog should be composed of.
    // Default value: 'beginning' (i.e. full changelog)
    // Possible values: 'beginning', 'last_tag', 'xxx'
    //
    // 'last_tag' will use all the commits since the last tag,
    // 'beginning' will use all commits since the initial commit (default)
    // 'xxx' will use all the tags since the 'xxx' Git reference (i.e. `since = 1.2.0` will display the changelog
    //       since the 1.2.0 tag, excluding 1.2.0)
    since = 'beginning'

    // The output formats that should be generated.
    // Default value: ['markdown']
    // Possible values: 'html', 'markdown'.
    formats = ['markdown', 'html']

    // The Git "pretty" changelog commit format.
    // Default value: %ad%x09%s (%an), which produces:
    // Thu May 7 20:10:33 2015 -0400    Initial commit (Alex Selesse)
    commitFormat = '%s (%an)'

    // A closure that returns 'true' if the line should be included in the changelog.
    // Default value: accept everything, { true }
    includeLines = {
        !it.contains("Merge")
    }

    // A closure that transforms a changelog String.
    // Default value: the identity closure, { it }
    //
    // For example, to remove '[ci skip]' from the changelog messages:
    processLines = {
        String input = it as String
        if (input.contains('[ci skip] ')) {
            input = input.minus('[ci skip] ')

            "* $input"
        } else if (input.empty) {
            input
        } else if (input.contains('---')) {
            input
        } else if (input == "Unreleased") {
            input
        } else {
            "* $input"
        }
    }
}

private String getTags() {
    def outStream = new ByteArrayOutputStream()
    String tags = ""

    try {
        exec {
            executable = "git"
            args = ["tag"]
            standardOutput = outStream
        }

        tags = outStream.toString().trim()
    }
    catch (e) {
        logger.quiet "Error while generating tags: $e"
    }

    return tags
}

private String getChangelog(final String fromTag, final String toTag) {
    def outStream = new ByteArrayOutputStream()
    String changelog = ""

    try {
        exec {
            executable = "git"
            args = ["log", "--pretty='%s (%an)'", "$fromTag..$toTag"]
            standardOutput = outStream
        }

        changelog = outStream.toString().trim()
    }
    catch (e) {
        logger.quiet "Error while generating theChangelog: $e"
    }

    return changelog
}

private String formatChangelog(String changelog) {
    final String[] split = changelog.split("\n")

    final StringBuilder result = new StringBuilder()
    final StringBuilder additions = new StringBuilder()
    final StringBuilder fixes = new StringBuilder()
    final StringBuilder changes = new StringBuilder()
    final StringBuilder removals = new StringBuilder()
    final StringBuilder misc = new StringBuilder()

    for (String s : split) {
        if (s.length() == 0) continue
        String temp = "\t" + s + "\r\n"

        switch (s.charAt(0)) {
            case '+':
                additions.insert(0, temp)
                break

            case '=':
                fixes.insert(0, temp)
                break

            case '~':
                changes.insert(0, temp)
                break

            case '-':
                removals.insert(0, temp)
                break

            default:
                misc.insert(0, temp)
                break
        }
    }

    if (additions.length() > 0) {
        additions.insert(0, "Additions:\r\n")
        result.append(additions)
    }
    if (fixes.length() > 0) {
        fixes.insert(0, "\r\nFixes:\r\n")
        result.append(fixes)
    }
    if (changes.length() > 0) {
        changes.insert(0, "\r\nChanges:\r\n")
        result.append(changes)
    }
    if (removals.length() > 0) {
        removals.insert(0, "\r\nRemovals:\r\n")
        result.append(removals)
    }
    if (misc.length() > 0) {
        misc.insert(0, "\r\nMisc:\r\n")
        result.append(misc)
    }

    return result.toString()
}

//String htmlFormat = formatChangelogToHTML()
//String mdFormat = formatChangelogToMD()

/**
 * Fetches tags to generate sections from tag to tag starting from no tag till first tag and so on till the HEAD
 */
//task generateHTMLChangelog(group: 'changelog', description: 'generates a HTML representation of the changelog.') << {
//    private String tags = tags;
//    private String[] splitTags = tags.split("\n")
//
//    logger.quiet "The last changelog:\n\n$log"
//}
//
//task generateMDChangelog(group: 'changelog', description: 'generates a MD representation of the changelog.') << {
//    generateMDChangelog()
//}
//
//private generateMDChangelog() {
//    private final String tags = this.getTags();
//    private final String[] splitTags = tags.split("\n")
//
//    private final StringBuilder newest = new StringBuilder()
//    private final String header = "$project.name - Changelog"
//    private final int headerLength = header.length()
//    private final String headerLine = this.generateHeaderLine(headerLength)
//    newest.append("$project.name - Changelog")
//    newest.appeng(headerLine)
//    newest.append('\n')
//
//    logger.quiet "The last changelog:\n\n$log"
//}
//
//private String generateHeaderLine(final int length) {
//    private final StringBuilder tempHeaderLine = new StringBuilder(length)
//    for(int i = 0; i < length; i++) {
//        tempHeaderLine.append('=')
//    }
//    private final String headerLine = tempHeaderLine.toString()
//
//    return headerLine
//}